## 第一周

### 1.数组

常用的一维数据结构。

### 2.链表

链表是2.0数组

头节点，尾节点。

### 3.跳表

时间复杂度O(log n)

空间复杂度O(n)

跳表是2.0链表，它是二维的数据结构。

通过在原始链表的基础上添加索引来优化查找等操作的时间复杂度。

### 4.栈

特点：后进先出 (LIFO)

添加，删除时间复杂度O(1)

查询的时间复杂度O(n)

### 5.队列

特点：先入先出

添加，删除时间复杂度O(1)

查询的时间复杂度O(n)

### 6.优先队列

插入时间复杂度O(1)

取出数据时间复杂度O(log n)

底层是多种样式的数据结构，如堆。



### 7.双端队列

头和尾都可以插入删除的一个队列

查询的时间复杂度O(n)

## 第二周

### 1.哈希表

哈希函数：查询,插入,删除O(1)，最坏的情况O(n)

哈希碰撞：解决方案有在发生冲突的位置实现一个链表来实现存储(拉链式解决方案)。

### 2.映射

实现是key-value对，其中key不可重复。

### 3.集合

不重复元素的集合。

### 4.树，二叉树，二叉搜索树



链表是特殊的树，因为它有两个指针。

树是特殊的图。

二叉树遍历：

前序：根左右

中序：左根右

后序：左右根

二叉树的代码实现通过递归。

二叉搜索树：指一棵空树或者满足一下条件的二叉树

左子树左右节点的值均小于根节点的值。

右子树左右节点的值均大于根节点的值。

插入，查询O(log n)

二叉搜索树的中序遍历是有序的。(升序)





### 5.堆和二叉堆

它用来迅速找到一组数据中的最大值或最小值。

查找O(1)

删除O(log n)

插入O(log n) 或者O(1)

大根堆

小根堆

二叉堆：通过完全二叉树来实现。

性质：

(1)它是一课完全树

(2)书中任意节点的值 大于等于 子节点的值

查找O(1)

删除O(log n)

插入O(log n)



Fibonacci 堆：时间复杂度更优。

### 6.图

结构中含有闭合的环。

## 第三周

### 1.泛型递归

递归的基本结构

### 2.树的递归



### 3.分治

分支的基本结构与递归类似。

### 4.回溯

回溯采用试错的思想

## 第四周

### DFS

深度优先搜索

用递归或栈来实现。

### BFS

广度优先搜索

实现一个队列。

### 贪心算法

它在每一步选择中都采取当前状态下最好或最优的选择。

它与DP的差异在于，对于每个子问题，它都做出选择且不能回退。

DP则可以保存之前所有的运算结果，并根据以前的结果来对下一步进行选择，可以进行回退。

### 二分查找

前提：

(1)目标函数单调性

(2)存在上下界

(3)能够通过索引进行访问

## 第五周

## 第六周

### 动态规划

DP和递归，分治没有根本区别。关键是看有没有最优子结构。

区别是DP在处理最优子结构的过程中可以淘汰次优解。

## 第七周

### 字典树Trie

又叫单词查找树，它不仅限于字符串的应用。

优点：减少无谓的字符串比较，查询效率高于哈希表。

基本性质：

(1)节点本身不存完整单词

(2)从根节点在某一结点，路径上经过的字符连接起来就是要查找的字符串

(3)每个节点的所有子节点路径所代表的字符串均不同。

核心思想：利用字符串的公共前缀来降低查找时间，从而提升效率。 

### 并查集

适用场景：组团，配对。

基本操作：

(1) 建立一个新的并查集，其中包含n个单元素集合。

(2) 把元素x和元素y所在的集合合并，要求x和y所在的集合不相交，如果相交则不合并。

(3) 找到x所在的集合的代表。

### 高级搜索

剪枝：剪掉无用的分支。

双向BFS

启发式函数：h(n),用来找到最优的节点，h(n)会返回一个非负实数，可以认为是从节点n的目标节点路径的估计成本。

启发式函数通过告知搜索方向，来更理智的猜测可能的路径。

### 红黑树

近似平衡二叉树。它能确保任何一个节点的左右子树的高度差小于2倍。

(1)每个节点要么是红色，要么是黑色

(2)根节点是黑色

(3)每个叶子结点是黑色。

(4)不能有相邻的两个红色节点

<u>(5)从任意节点到每个叶子节点的所有路径都会包含相同数目的黑色节点。</u>

O(log n)

### AVL树

引入平衡因子来保证平衡。

平衡因子：左子树高度 - 右子树高度。因此取值范围是{-1,0,1}

旋转操作，左旋，右旋，左右旋，右左旋。

avl树的缺点：节点需要存储额外的信息(平衡因子等)，且调整次数频繁(四种旋转)。

## 第八周

### 位运算

判断奇偶：

(x&1) == 1

(x&1) == 0

除二：

x = x >> 1

清零最低位的1：

x = x &(x - 1)

得到最低位的1：

x & -x => 1

### 布隆过滤器

它是一个很长的二进制向量和一系列随机映射函数。

它用来检索一个元素是否在一个集合中

它仅存储在或者不在的信息，其他的信息不存。

优点是提升时间和空间的效率，不足是有一定的误识别率和删除困难。

应用场景：分布式系统Map-Reduce，Hadoop，redis缓存，对于指定信息的过滤。

### LRU Cache

两大要素：大小，替换策略。

替换策略：最近最少使用

实现：Hash Table + double linked list

### 排序算法

比较排序：冒泡，快排，插入，希尔，堆，归并

非比较排序：计数，桶，基数。



堆，快排，归并。 O(n log n)



初级排序：选择排序，插入排序，冒泡排序，O(n ^2) 

高级排序：

快排 ：在数组中取一个pivot。将小于的元素置左，大于的置右。然后对两侧进行排序。

归并排序：使用分治。分成两个子序列，将两个子序列进行排序，然后合并。



归并：先排序左右子数组，然后合并这两个有序数组。

快排：先调配出左右两个子数组，然后对于左右两个子数组进行排序。



堆排序：插入O(log n),   取值O(1)。

在数组元素依次建立小顶堆，依次取出堆顶元素，并删除。

## 第九周

### 高级动态规划

DP和递归，分治没有根本区别。关键是看有没有最优子结构。

区别是DP在处理最优子结构的过程中可以淘汰次优解。

### 